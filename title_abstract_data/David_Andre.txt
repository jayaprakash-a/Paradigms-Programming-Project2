PARALLEL GENETIC PROGRAMMING ON A NETWORK OF TRANSPUTERS| ABSTRACT This paper describes the parallel implementation of genetic programming in the C programming language using a PC 486 type computer running Windows acting as a host and a network of transputers acting as processing nodes.  Using this approach, researchers of genetic algorithms and genetic programming can acquire computing power that is intermediate between the power of currently available workstations and that of supercomputers at a cost that is intermediate between the two.  A comparison is made of the computational effort required to solve the problem of symbolic regression of the Boolean even-5-parity function with different migration rates.  Genetic programming required the least computational effort with migration rate at 5%; however, there was little difference in performance for migration rates between 1% and 8%.  Moreover, this computational effort required for these migration rates was less than that required for solving the problem with a serial computer and a panmictic population of the same size.  That is, apart from the nearly linear speed-up in executing a fixed amount of code inherent in the parallel implementation of genetic programming, parallelization delivered more than linear speed-up in solving the problem using genetic programming. 
Using Programmatic Motifs and Genetic Programming to Classify Protein Sequences as to Cellular Location| Abstract: As newly sequenced proteins are deposited into the world's evergrowing archives, they are typically immediately tested by various algorithms for clues as to their biological structure and function.  One question about a new protein involves its cellular location -- that is, where the protein resides in a living organism (e. g. , extracellular, membrane, nuclear).  A human-created five-way algorithm for cellular location using statistical techniques with 76% accuracy was recently reported.  This paper describes a two-way algorithm that was evolved using genetic programming with 83% accuracy for determining whether a protein is an extracellular protein, 84% for nuclear proteins, 89% for membrane proteins, and 83% for anchored membrane proteins.  Unlike the statistical calculation, the genetically evolved programs employ a large and varied arsenal of computational capabilities, including arithmetic functions, conditional operations, subroutines, iterations, named memory, indexed memory, set-creating operations, and look-ahead.  The genetically evolved classification program can be viewed as an extension (which we call a programmatic motif) of the conventional notion of a protein motif. 
for AAAI Fall Symposium on Genetic Programming in Cambirdge on November| ABSTRACT Automated methods of machine learning may prove to be useful in discovering biologically meaningful information hidden in the rapidly growing databases of DNA sequences and protein sequences.  Genetic programming is an extension of the genetic algorithm in which a population of computer programs is bred, over a series of generations, in order to solve a problem.  Genetic programming is capable of evolving complicated problem-solving expressions of unspecified size and shape.  Moreover, when automatically defined functions are added to genetic programming, genetic programming becomes capable of efficiently capturing and exploiting recurring sub-patterns.  This chapter describes how genetic programming with automatically defined functions successfully evolved motifs for detecting the D-E-A-D box family of proteins and for detecting the manganese superoxide dismutase family.  Both motifs were evolved without prespecifying their length.  Both evolved motifs employed automatically defined functions to capture the repeated use of common subexpressions.  When tested against the SWISS-PROT database of proteins, the two genetically evolved consensus motifs detect the two families either as well, or slightly better than, the comparable human-written motifs found in the PROSITE database. 
Automated WYWIWYG Design of Both the Topology and Component Values of Electrical Circuits Using Genetic Programming| ABSTRACT This paper describes an automated process for designing electrical circuits in which "What You Want Is What You Get" ("WYWIWYG" -- pronounced "wow-eee-wig").  The design process uses genetic programming to produce both the topology of the desired circuit and the sizing (numerical values) for all the components of a circuit.  Genetic programming successfully evolves both the topology and the sizing for an asymmetric bandpass filter that was described as being difficult-to-design in a leading electrical engineering journal.  This evolved circuit is another instance in which a genetically evolved solution to a non-trivial problem is competitive with human performance. 
A CASE STUDY WHERE BIOLOGY INSPIRED A SOLUTION TO A COMPUTER SCIENCE PROBLEM| ABSTRACT This paper describes how the biological theory of gene duplication described in Susumu Ohno's provocative book, Evolution by Means of Gene Duplication, was brought to bear on a vexatious problem from the domain of automated machine learning, namely the problem of architecture discovery.  Six new architecture-altering operations for genetic programming were motivated by the way that new biological structures, functions, and behaviors arise in nature using gene duplication.  Genetic programming with the new architecture-altering operations was then applied to the transmembrane protein segment identification problem.  The out-of-sample error rate for the best genetically-evolved program achieved was slightly better than that of previously-reported human-written algorithms for this problem. 
Obstacle Avoidance Via Depth From Focus| Abstract ARPA Image Understanding Workshop 1996 A critical challenge in the creation of autonomous mobile robots is the reliable detection of moving and static obstacles.  In this paper, we present a passive vision system that recovers coarse depth information reliably and efficiently.  This system is based on the concept of depth from focus, and robustly locates static and moving obstacles as well as stairs and dropo#s with adequate accuracy for navigation.  We describe an implementation of this vision system on a mobile robot as well as real-world experiments both indoors and outdoors.  These experiments haveinvolved several hours of continuous and fully autonomous operation in crowded, natural settings. 
Representations for Learning Control Policies| Abstract Representing the expected reward or cost for taking an action in a stochastic control problem, such as automated driving, is not trivial when the state and action spaces are continuous.  Simple techniques can suffer from forgetting, where the lessons learned when the agent was doing poorly (e. g.  how to recover when the car is headed off the road) can be forgotten when the agent has learned a policy that works in the majority of cases.  This paper presents and demonstrates a method that effectively learns and maintains a Q function approximation utilizing stored instances of past observations.  This instance-based reinforcement learning algorithm has the necessary extensions and optimizations required to learn in complex control domains.  To make further use of the stored examples, our method learns a model of the environment and uses that model to improve the estimate of the value of taking actions in states.  We explore several techniques for choosing how to use the model to eciently improve the value function, and present an original algorithm based on generalized prioritized sweeping that outperforms the others on two example driving tasks.  In our experience, the task of learning to control an autonomous vehicle is best formulated as a stochastic optimal control problem.  Reinforcement learning (RL) algorithms can learn optimal behavior for such problems from trial and error interactions with the environment.  However, reinforcement learning algorithms often are unable to effectively learn policies for domains with certain properties: continuous state and action spaces, a need for real-time online operation, and continuous long-term operation.  Driving is a particularly challenging problem, since the task itself changes over time.  A lane following agent may become proficient at negotiating curved roads and then go on a long straight stretch where it becomes even more proficient on straight roads.  It should not, however, lose proficiency at the curved roads.  The overall goal of staying in the center of the lane remains the same, but the kind of states with which the agent is faced changes when moving from curved roads to straight and back again.  Many learning algorithms are vulnerable to catastrophic interference where, after experiencing numerous new examples in a different part of the state space, accuracy on older examples can decrease.  This behavior is referred to as forgetting.  As in real life, forgetting is obviously inadvisable for any learning control algorithm.  Instance-based learners are an example of nonparametric learners and thus avoid the problem of forgetting.  Applying them directly to reinforcement learning, however, is not entirely trivial, as the reinforcement learning problem is not a supervised learning problem, but a delayed reinforcement problem.  Furthermore, instance based techniques use a lot of memory, and are susceptible to the magnitudes of the inputs.  This paper presents techniques that avoid the above diculties by using a value-updating algorithm, instance averaging, and automatic dimension scaling.  Finally, reinforcement learning can require many runs in the environment to learn a successful policy.  We mitigate this by using memory-based reinforcement learning, which learns a model of the environment and uses it to improve the value function without taking steps in the actual environment.  Many methods have been suggested for how best to use a model to update the value function.  We utilize a novel method for our representation based on generalized prioritized sweeping (Andre et al. , 1997).  We demonstrate our methods on two simulated driving tasks.  The structure of this paper is as follows.  Section 1 describes the instance-based representation for value function approximation and how it can be used to learn control policies effectively from experience.  This section also describes the extensions that were necessary for the representation to be practical for vehicle control.  Section 2 shows how one can use a structured domain model to learn more eciently and handle fundamental autonomous vehicle tasks.  Section 3 presents some empirical results on learning to control a simulated vehicle to steer itself in the center of the lane.  The paper ends with conclusions and acknowledgments. 
Evolution of a 60 Decibel Op Amp Using Genetic Programming| Abstract: Genetic programming was used to evolve both the topology and sizing (numerical values) for each component of a low-distortion, low-bias 60 decibel (1000-to-1) amplifier with good frequency generalization. 
Evolution of a Low-Distortion, Low-Bias 60 Decibel Op Amp with Good Frequency Generalization using Genetic Programming| ABSTRACT Genetic programming was used to evolve both the topology and the sizing (numerical values) for each component of a low-distortion, low-bias 60 decibel (1000to-1) amplifier circuit with good frequency generalization.  The evolved circuit was composed of two types of transistors (active elements) as well as resistors and capacitors. 
Classifying Proteins as Extracellular using Programmatic Motifs and Genetic Programming| Abstract As newly sequenced proteins are deposited into the world's ever-growing archive of protein sequences, they are typically immediately tested by various computerized algorithms for clues as to their biological structure and function.  One question about a new protein involves its cellular location -- that is, where the protein resides in a living organism (extracellular, intracellular, etc. ).  A 1997 paper reported a human-created five-way algorithm for cellular location created using statistical techniques with 76% accuracy.  This paper describes a two-way classification algorithm that was evolved using genetic programming with 83% accuracy for determining whether a protein is extracellular.  Unlike the statistical calculation, the genetically evolved algorithm employs a large and varied arsenal of computational capabilities,
State Abstraction for Programmable Reinforcement Learning| Abstract Safe state abstraction in reinforcement learning allows an agent to ignore aspects of its current state that are irrelevant to its current decision, and therefore speeds up dynamic programming and learning.  Like Dietterich's MAXQ framework, this paper develops methods for safe state abstraction in the context of hierarchical reinforcement learning, in which a hierarchical partial program is used to constrain the policies that are considered.  We extend techniques from MAXQ to the context of programmable hierarchical abstract machines (PHAMs), which express complex parameterized behaviors using a simple extension of the Lisp language.  We show that our methods preserve the property of hierarchical optimality, i. e. , optimality among all policies consistent with the PHAM program.  We also show how our methods allow safe detachment, encapsulation, and transfer of learned "subroutine" behaviors, and demonstrate our methods on Dietterich's taxi domain. 
Automatic Programming of a Time-Optimal Robot Controller and an Analog Electrical Circuit to Implement the Robot Controller by Means of Genetic Programming| ABSTRACT Genetic programming is an automatic programming technique that evolves computer programs to solve, or approximately solve, problems.  This paper presents two examples in which genetic programming creates a computer program for controlling a robot so that the robot moves to a specified destination point in minimal time.  In the first approach, genetic programming evolves a computer program composed of ordinary arithmetic operations and conditional operations to implement a time-optimal control strategy.  In the second approach, genetic programming evolves the design of an analog electrical circuit consisting of transistors, diodes, resistors, and power supplies to implement a near-optimal control strategy. 
AUTOMATIC CREATION OF COMPUTER PROGRAMS FOR DESIGNING ELECTRICAL CIRCUITS USING GENETIC PROGRAMMING| One of the central goals of computer science is to get computers to solve problems starting from only a high-level statement of the problem.  The goal of automating the design process bears many similarities to the goal of automatically creating computer programs.  The design process entails creation of a complex structure to satisfy user-defined requirements.  The design process is usually viewed as requiring human intelligence.  Indeed, design is a major activity of practicing engineers.  For these reasons, the design process offers a practical yardstick for evaluating automated programming (program synthesis) techniques.  In particular, the design (synthesis) of analog electrical circuits entails the creation of both the topology and sizing (numerical values) of all of a circuit's components.  There has previously been no general automated technique for automatically designing an analog electrical circuit from a high-level statement of the circuit's desired behavior.  This paper shows how genetic programming can be used to automate the design of both the topology and sizing of a suite of five prototypical analog circuits, including a lowpass filter, a tri-state frequency discriminator circuit, a 60 dB amplifier, a computational circuit for the square root, and a time-optimal robot controller circuit.  All five of these genetically evolved circuits constitute instances of an evolutionary computation technique solving a problem that is usually thought to require human intelligence. 
Design of a High-Gain Operational Amplifier and Other Circuits by Means of Genetic Programming| Abstract: This paper demonstrates that a design for a low-distortion high-gain 96 decibel (64,860 -to-1) operational amplifier (including both circuit topology and component sizing) can be evolved using genetic programming. 
AUTOMATED DESIGN OF BOTH THE TOPOLOGY AND SIZING OF ANALOG ELECTRICAL CIRCUITS USING GENETIC PROGRAMMING| Abstract: This paper describes an automated process for designing analog electrical circuits based on the principles of natural selection, sexual recombination, and developmental biology.  The design process starts with the random creation of a large population of program trees composed of circuit-constructing functions.  Each program tree specifies the steps by which a fully developed circuit is to be progressively developed from a common embryonic circuit appropriate for the type of circuit that the user wishes to design.  Each fully developed circuit is translated into a netlist, simulated using a modified version of SPICE, and evaluated as to how well it satisfies the user's design requirements.  The fitness measure is a user-written computer program that may incorporate any calculable characteristic or combination of characteristics of the circuit, including the circuit's behavior in the time domain, its behavior in the frequency domain, its power consumption, the number of components, cost of components, or surface area occupied by its components.  The population of program trees is genetically bred over a series of many generations using genetic programming.  Genetic programming is driven by a fitness measure and employs genetic operations such as Darwinian reproduction, sexual recombination (crossover), and occasional mutation to create offspring.  This automated evolutionary process produces both the topology of the circuit and the numerical values for each component.  This paper describes how genetic programming can evolve the circuit for a difficult-to-design low-pass filter.  1.  The Problem of Circuit Design The design of an electrical circuit with specified operating characteristics is a complex task.  Electrical circuits consist of a wide variety of different types of components,
Use of Automatically Defined Functions and ArchitectureAltering Operations in Automated Circuit Synthesis with Genetic Programming| ABSTRACT This paper demonstrates the usefulness of automatically defined functions and architecture-altering operations in designing analog electrical circuits using genetic programming.  A design for a lowpass filter is genetically evolved in which an automatically defined function is profitably reused in the 100% compliant circuit.  The symmetric reuse of an evolved substructure directly enhances the performance of the circuit.  Genetic programming rediscovered the classical ladder topology used in Butterworth and Chebychev filters as well as the more complex topology used in Cauer (elliptic) filters.  A design for a double-passband filter is genetically evolved in which the architecture-altering operations discover a suitable program architecture dynamically during the run.  Two automatically defined functions are profitably reused in the genetically evolved 100% complaint circuit. 
Reuse, Parameterized Reuse, and Hierarchical Reuse of Substructures in Evolving Electrical Circuits Using Genetic Programming| Abstract: Most practical electrical circuits contain modular substructures that are repeatedly used to create the overall circuit.  Genetic programming with automatically defined functions and the recently developed architecturealtering operations provides a way to build complex structures with reused substructures.  In this paper, we successfully evolved a design for a twoband crossover (woofer and tweeter) filter with a crossover frequency of 2,512 Hz.  Both the topology and the sizing (numerical values) for each component of the circuit were evolved during the run.  The evolved circuit contained three different noteworthy substructures.  One substructure was invoked five times thereby illustrating reuse.  A second substructure was invoked with different numerical arguments.  This second substructure illustrates parameterized reuse because different numerical values were assigned to the components in the different instantiations of the substructure.  A third substructure was invoked as part of a hierarchy, thereby illustrating hierarchical reuse. 
Toward Evolution of Electronic Animals Using Genetic Programming| Abstract This paper describes an automated process for designing an optimal food-foraging controller for a lizard.  The controller consists of an analog electrical circuit that is evolved using the principles of natural selection, sexual recombination, and developmental biology.  Genetic programming creates both the topology of the controller circuit and the numerical values for each electrical component. 
Design of a 96 Decibel Operational Amplifier and Other Problems for Which a Computer Program Evolved by Genetic Programming is Competitive with Human Performance| Abstract It would be desirable if computers could solve problems without the need for a human to write the detailed programmatic steps.  That is, it would be desirable to have a domain-independent automatic programming technique in which "What You Want Is What You Get" ("WYWIWYG" -- pronounced "wow-eee-wig").  Genetic programming is such a technique.  This paper surveys three recent examples of problems (one from the field of cellular automata and two from the fields of molecular biology) in which genetic programming evolved a computer program that produced results that were slightly better than human performance for the same problem.  This paper then discusses a fourth problem in greater detail and demonstrates that a design for a low-distortion 96 decibel op amp (including both topology and component sizing) can be evolved using genetic programming.  The information that the user must supply to genetic programming consists of the parts bin (transistors, resistors, and capacitors) and the fitness measure for the major operating characteristics of an op amp. 
Evolving Computer Programs Using Rapidly Reconfigurable Field-Programmable Gate Arrays and Genetic Programming| ABSTRACT This paper describes how the massive parallelism of the rapidly reconfigurable Xilinx XC6216 FPGA (in conjunction with Virtual Computing's H. O. T.  Works board) can be exploited to accelerate the timeconsuming fitness measurement task of genetic algorithms and genetic programming.  This acceleration is accomplished by embodying each individual of the evolving population into hardware in order to perform the fitness measurement task.  A 16-step sorting network for seven items was evolved that has two fewer steps than the sorting network described in the 1962 O'Connor and Nelson patent on sorting networks (and the same number of steps as a 7-sorter that was devised by Floyd and Knuth subsequent to the patent and that is now known to be minimal).  Other minimal sorters have been evolved. 
Discovery by Genetic Programming of a Cellular Automata Rule that is Better than any Known Rule for the Majority Classification Problem| ABSTRACT It is difficult to program cellular automata.  This is especially true when the desired computation requires global communication and global integration of information across great distances in the cellular space.  Various human-written algorithms have appeared in the past two decades for the vexatious majority classification task for one-dimensional two-state cellular automata.  This paper describes how genetic programming with automatically defined functions evolved a rule for this task with an accuracy of 82. 326%.  This level of accuracy exceeds that of the original 1978 GacsKurdyumov-Levin (GKL) rule, all other known human-written rules, and all other known rules produced by automated methods.  The rule evolved by genetic programming is qualitatively different from all previous rules in that it employs a larger and more intricate repertoire of domains and particles to represent and communicate information across the cellular space. 
for special issue of Computer Methods in Applied Mechanics and Engineering (CMAME journal) edited by| Abstract The design (synthesis) of an analog electrical circuit entails the creation of both the topology and sizing (numerical values) of all of the circuit's components.  There has previously been no general automated technique for automatically creating the design for an analog electrical circuit from a high-level statement of the circuit's desired behavior.  This paper shows how genetic programming can be used to automate the design of eight prototypical analog circuits, including a lowpass filter, a highpass filter, a bandstop filter, a tristate frequency discriminator circuit, a frequency-measuring circuit, a 60 dB amplifier, a computational circuit for the square root function, and a time-optimal robot controller circuit. 
Evolutionary Computation: Theory and Applications edited by Xin Yao| Automatic Discovery of Protein Motifs Using Genetic Programming.  ABSTRACT Automated methods of machine learning may prove to be useful in discovering biologically meaningful information hidden in the rapidly growing databases of DNA sequences and protein sequences.  Genetic programming is an extension of the genetic algorithm in which a population of computer programs is bred, over a series of generations, in order to solve a problem.  Genetic programming is capable of evolving complicated problem-solving expressions of unspecified size and shape.  Moreover, when automatically defined functions are added to genetic programming, genetic programming becomes capable of efficiently capturing and exploiting recurring sub-patterns.  This chapter describes how genetic programming with automatically defined functions successfully evolved motifs for detecting the D-E-A-D box family of proteins and for detecting the manganese superoxide dismutase family.  Both motifs were evolved without prespecifying their length.  Both evolved motifs employed automatically defined functions to capture the repeated use of common subexpressions.  When tested against the SWISSPROT database of proteins, the two genetically evolved consensus motifs detect the two families either as well, or slightly better than, the comparable human-written motifs found in the PROSITE database. 
Evolution of a Time-Optimal Fly-To Controller Circuit using Genetic Programming| ABSTRACT Most problem-solving techniques used by engineers involve the introduction of analytical and mathematical representations and techniques that are entirely foreign to the problem at hand.  Genetic programming offers the possibility of solving problems in a more direct way using the given ingredients of the problem.  This idea is explored by considering the problem of designing an electrical controller to implement a solution to the time-optimal fly-to control problem. 
Evolving Sorting Networks using Genetic Programming and Rapidly Reconfigurable Field-Programmable Gate Arrays| ABSTRACT This paper describes ongoing work involving the use of the Xilinx XC6216 rapidly reconfigurable fieldprogrammable gate array to evolve sorting networks using genetic programming.  We successfully evolved a network for sorting seven items that employs two fewer steps than the sorting network described in a l962 patent and that has the same number of steps as the seven-sorter devised by Floyd and Knuth subsequent to the patent. 
Evolution using genetic programming of a low-distortion, 96 decibel operational amplifier| KEYWORDS Genetic programming, Automated circuit design, Analog circuit synthesis, operational amplifier ABSTRACT There is no known general technique for automatically designing an analog electrical circuit that satisfies design specifications.  Genetic programming was used to evolve both the topology and the sizing (numerical values) for each component of a low-distortion 96 decibel (64,860 -to-1) amplifier circuit.  1.  THE ANALOG DILEMMA The field of engineering design offers a practical yardstick for evaluating automated techniques because the design process is usually viewed as requiring human intelligence and because design is a major activity of practicing engineers.  In the design process, the design requirements specify "what needs to be done. " A satisfactory design tells us "how to do it. " In the field of electrical engineering, the design process typically involves the creation of an electrical circuit that satisfies user-specified design goals.  Considerable progress has been made in automating the design of certain categories of purely digital circuits; however, the design of analog circuits and mixed analog-digital circuitshas not proved to be as amenable to automation (Rutenbar 1993).  In discussing "the analog dilemma," O.  Aaserud and I.  Ring Nielsen (1995) (not to be confused with Ivan Riis Nielsen cited later) observe, "Analog designers are few and far between.  In contrast to digital design, most of the analog circuits are still handcrafted by the experts or so-called 'zahs' of analog design.  The design process is characterized by a combination of experience and intuition and requires a thorough knowledge of the process characteristics and the detailed specifications of the actual product.  "Analog circuit design is known to be a knowledge-intensive, multiphase, iterative task, which usually stretches over a significant period of time and is performed by designers with a large portfolio of skills.  It is therefore considered by many to be a form of art rather than a science. " Of course, engineers employ human reasoning abilities and intelligence in designing complex structures.  In contrast, nature employs an entirely different approach to design.  In nature, complex structures are designed by means of evolution and natural selection.  This suggests the possibility of applying the techniques of evolutionary computation in order to automate the design of complex structures.  Genetic algorithms have been applied to the problem of circuit synthesis.  A CMOS operational amplifier (op amp) circuit was designed using a modified version of the genetic algorithm (Kruiskamp and Leenaerts 1995); however, the topology of each op amp was one of 24 pre-selected topologies based on the conventional human-designed stages of an op amp.  Thompson (1996) used a genetic algorithm to evolve a frequency discriminator on a Xilinx 6216 reconfigurable digital gate array operating in analog mode.  Holland (1975) described how an analog of the naturally-occurring evolutionary process can be applied to solving scientific and engineering problems using what is now called the genetic algorithm (GA).  Koza (1992) described an extension of Holland's genetic algorithm in which the population consists of computer programs.  See also Koza and Rice 1992.  Koza (1994a, 1994b) described a way to evolve multipart programs consisting of a main program and one or more reusable, parameterized, hierarchically-called subprograms (called automatically defined functions).  Architecture-altering operations provide a way to automatically determine the number of such subprograms, the number of arguments that each possesses, and the nature of the hierarchical references, if any, among such subprograms (Koza 1995).  Recent research papers on genetic programming can be found in Kinnear (1994), Angeline and Kinnear (1996), and Koza, Goldberg, Fogel, and Riolo (1996).  Gruau's cellular encoding (1996) is an innovative technique in which genetic programming is used to concurrently evolve the architecture, weights, thresholds, and biases of neurons in a neural network.  This paper demonstrates that a design for a lowdistortion 96 decibel (dB) op amp (including both the circuit topology and component sizing) can be evolved using genetic programming.  The problem-specific information that the user must supply in order to apply genetic programming to a particular new problem of analog circuit synthesis is minimal; it primarily consists of a fitness measure for the operating characteristics of the desired circuit.  The user must also specify certain additional basic information such as the number of inputs and outputs of the desired circuit, the set of parts that are to be available to the circuit (e. g. , transistors, resistors, and capacitors), and the repertoire of circuitconstructing functions (which generally does not vary from problem to problem).  Additional evidence of the ability of genetic programming to evolve the design for analog electrical circuits was presented by showing genetically evolved designs for other types of circuits, including a lowpass filter, an asymmetric bandpass filter, and a crossover (woofer and tweeter) filter.  2.  Circuit-Constructing Program Trees Genetic programming can be applied to circuits if a mapping is established between the kind of rooted, point-labeled trees with ordered branches found in genetic programming and the line-labeled cyclic graphs germane to circuits.  The principles of developmental biology suggest a way to map program trees into circuits.  The starting point of the growth process used herein is a very simple embryonic electrical circuit.  The embryonic circuit contains certain fixed parts appropriate to the problem at hand and certain wires that are capable of subsequent modification.  An electrical circuit is progressively developed by applying the functions in a circuitconstructing program tree to the modifiable wires of the embryonic circuit (and, later, to both the modifiable wires and other components of the successor circuits).  The functions in the circuit-constructing program trees are divided into four categories: (1) connection-modifying functions that modify the topology of the circuit, (2) component-creating functions that insert components into the circuit, (3) arithmetic-performing functions that appear in arithmetic-performing subtrees as argument(s) to the component-creating functions and that specify the numerical value of the component, and (4) automatically defined functions that appear in function-defining branches and potentially enable certain substructures to be reused.  Each branch of the program tree is created in accordance with a constrained syntactic structure.  Branches are composed from construction-continuing subtrees that continue the developmental process and arithmetic-performing subtrees that determine the numerical value of components.  Connection-modifying functions have one or more construction-continuing subtrees, but no arithmetic-performing subtrees.  Component-creating functions have one constructioncontinuing subtree and typically have one arithmeticperforming subtree.  This constrained syntactic structure is preserved by using structure-preserving crossover with point typing (Koza 1994a).  2. 1.  The Embryonic Circuit The developmental process for converting a program tree into an electrical circuit begins with an embryonic circuit.  Figure 1 Feedback embryo for an amplifier.  corrected 10-96 version of N:\fhb\tojohn\r708826e. doc Figure 1 shows a one-input, one-output embryonic circuit that serves as a test harness for evolving op amp circuits.  VSOURCE is the input signal.  VOUT is the output signal.  There is a fixed 100 Ohm load resistor RLOAD and a fixed 100 Ohm source resistor RSOURCE.  At the beginning of the developmental process, there is a writing head pointing to (highlighting) each of the three modifiable wires (Z0, Z1, and Z2).  All development occurs at wires or components to which a writing head points.  The three modifiable wires provide connectivity between the three distinct
IEEE Transactions on Evolutionary Computation| Automated Synthesis of Analog Electrical Circuits by Means of Genetic Programming.  Abstract -- The design (synthesis) of analog electrical circuits starts with a highlevel statement of the circuit's desired behavior and requires creating a circuit that satisfies the specified design goals.  Analog circuit synthesis entails the creation of both the topology and the sizing (numerical values) of all of the circuit's components.  The difficulty of the problem of analog circuit synthesis is well known and there is no previously known general automated technique for synthesizing an analog circuit from a high-level statement of the circuit's desired behavior.  This paper presents a single uniform approach using genetic programming for the automatic synthesis of both the topology and sizing of a suite of eight different prototypical analog circuits, including a lowpass filter, a crossover (woofer and tweeter) filter, a source identification circuit, an amplifier, a computational circuit, a timeoptimal controller circuit, a temperature-sensing circuit, and a voltage reference circuit.  The problem-specific information required for each of the eight problems is minimal and consists primarily of the number of inputs and outputs of the desired circuit, the types of available components, and a fitness measure that restates the highlevel statement of the circuit's desired behavior as a measurable mathematical quantity.  The eight genetically evolved circuits constitute an instance of an evolutionary computation technique producing results on a task that is usually thought of as requiring human intelligence.  The fact that a single uniform approach yielded a satisfactory design for each of the eight circuits as well as the fact that a satisfactory design was created on the first or second run of each problem are evidence for the general applicability of genetic programming for solving the problem of automatic synthesis of analog electrical circuits. 
Programmable Reinforcement Learning Agents| Abstract We present an expressive agent design language for reinforcement learning that allows the user to constrain the policies considered by the learning process. The language includes standard features such as parameterized subroutines, temporary interrupts, aborts, and memory variables, but also allows for unspecified choices in the agent program.  For learning that which isn't specified, we present provably convergent learning algorithms.  We demonstrate by example that agent programs written in the language are concise as well as modular.  This facilitates state abstraction and the transferability of learned skills. 
Detecting Unsolvable Queries for Definite Logic Programs| Abstract In solving a query, the SLD proof procedure for definite programs sometimes searches an infinite space for
Evolution of Iteration in Genetic Programming| ABSTRACT The solution to many problems requires, or is facilitated by, the use of iteration.  Moreover, because iterative steps are repeatedly executed, they must have some degree of generality.  An automatic programming system should require that the user make as few problem-specific decisions as possible concerning the size, shape, and character of the ultimate solution to the problem.  Work first presented at the Fourth Annual Conference on Evolutionary Programming in 1995 (EP-95) demonstrated that six then-new architecture-altering operations made it possible to automate the decision about the architecture of an overall program dynamically during a run of genetic programming.  The question arises as to whether it is also possible to automate the decision about whether to employ iteration, how much iteration to employ, and the particular sequence of iterative steps.  This paper introduces the new operation of restricted iteration creation that automatically creates a restricted iteration-performing branch out of a portion of an existing computer program during a run a genetic programming.  Genetic programming with the new operation is then used (in conjunction with the other architecture-altering operations first presented at EP-95) to evolve a computer program to solve a non-trivial problem. 
for Evolution as Computation Workshop (EAC) at DIMACS to be held in Princeton, New Jersey on January 11 --| Abstract This paper describes a biologically inspired domain-independent technique, called genetic programming, that automatically creates computer programs to solve problems.  Starting with a primordial ooze of thousands of randomly created computer programs, genetic programming progressively breeds a population of computer programs over a series of generations using the Darwinian principle of natural selection, recombination (crossover), mutation, gene duplication, gene deletion, and certain mechanisms of developmental biology.  The technique is illustrated by applying it to a non-trivial problem involving the automatic synthesis (design) of a lowpass filter circuit.  The evolved results are competitive with human-produced solutions to the problem.  In fact, four of the automatically created circuits exhibit human-level creativity and inventiveness, as evidenced by the fact that they correspond to four inventions that were patented between 1917 and 1936. 
Automatic Design of Analog Electrical Circuits using Genetic Programming| ABSTRACT The design (synthesis) of analog electrical circuits entails the creation of both the topology and sizing (numerical values) of all of the circuit's components.  There has previously been no general automated technique for automatically designing an analog electrical circuit from a high-level statement of the circuit's desired behavior.  This chapter introduces genetic programming and shows how it can be used to automate the design of both the topology and sizing of a suite of five prototypical analog circuits, including a lowpass filter, a tri-state frequency discriminator circuit, a 60 dB amplifier, a computational circuit for the square root, and a time-optimal robot controller circuit.  The problem-specific information required for each of the eight problems is minimal and consists primarily of the number of inputs and outputs of the desired circuit, the types of available components, and a fitness measure that restates the high-level statement of the circuit's desired behavior as a measurable mathematical quantity.  All five of these genetically evolved circuits constitute instances of an evolutionary computation technique solving a problem that is usually thought to require human intelligence. 
Automated Synthesis of Computational Circuits Using Genetic Programming| Computational circuits are of special practical importance when the small number of required mathematical functions does not warrant converting an analog signal into a digital signal, performing the mathematical function in the digital domain, and then converting the result back to the analog domain.  The design of computational circuits is difficult even for mundane mathematical functions and often relies on the clever exploitation of some aspect of the underlying device physics of the components.  Moreover, implementation of each different mathematical function typically requires an entirely different clever insight.  This paper demonstrates that computational circuits can be designed without such problem-specific insights using a single uniform approach involving genetic programming.  Both the circuit topology and the sizing of all circuit components are created by genetic programming.  This uniform approach to the automated synthesis of computational circuits is illustrated by evolving circuits that perform the cube root function (for which no circuit was found in the published literature) as well as for the square root, square, and cube functions. 
Model based Bayesian Exploration| Abstract Reinforcement learning systems are often concerned with balancing exploration of untested actions against exploitation of actions that are known to be good.  The benefit of exploration can be estimated using the classical notion of Value of Information --- the expected improvement in future decision quality arising from the information acquired by exploration.  Estimating this quantity requires an assessment of the agent's uncertainty about its current value estimates for states.  In this paper we investigate ways to represent and reason about this uncertainty in algorithms where the system attempts to learn a model of its environment.  We explicitly represent uncertainty about the parameters of the model and build probability distributions over Qvalues based on these.  These distributions are used to compute a myopic approximation to the value of information for each action and hence to select the action that best balances exploration and exploitation. 
Evolution of a Tri-State Frequency Discriminator for the Source Identification Problem using Genetic Programming| KEYWORDS Genetic programming, Automated design of analog electrical circuits, Source identification problem, Frequency discrimination ABSTRACT Automated synthesis of analog electronic circuits is recognized as a difficult problem.  Genetic programming was used to evolve both the topology and the sizing (numerical values) for each component of a circuit that can perform source identification by correctly classify an incoming signal into categories. 
A Parallel Implementation of Genetic Programming that Achieves Super-Linear Performance| Abstract: This paper describes the successful parallel implementation of genetic programming on a network of processing nodes using the transputer architecture.  With this approach, researchers of genetic algorithms and genetic programming can acquire computing power that is intermediate between the power of currently available workstations and that of supercomputers at intermediate cost.  This approach is illustrated by a comparison of the computational effort required to solve a benchmark problem.  Because of the decoupled character of genetic programming, our approach achieved a nearly linear speed up from parallelization.  In addition, for the best choice of parameters tested, the use of subpopulations delivered a super linear speed-up in terms of the ability of the algorithm to solve the problem.  Several examples are also presented where the parallel genetic programming system evolved solutions that are competitive with human performance on the same problem. 
Genetic Programming: Biologically Inspired Computation that Creatively Solves Non-Trivial Problems| Abstract.  This paper describes a biologically inspired domain-independent technique, called genetic programming, that automatically creates computer programs to solve problems.  Starting with a primordial ooze of thousands of randomly created computer programs, genetic programming progressively breeds a population of computer programs over a series of generations using the Darwinian principle of natural selection, recombination (crossover), mutation, gene duplication, gene deletion, and certain mechanisms of developmental biology.  The technique is illustrated by applying it to a non-trivial problem involving the automatic synthesis (design) of alowpass filter circuit.  The evolved results are competitive with human-produced solutions to the problem.  In fact, four of the automatically created circuits exhibit human-level creativity and inventiveness, as evidenced by the fact that they correspond to four inventions that were patented between 1917 and 1936. 
Evolving Team Darwin United| Abstract.  The RoboCup simulator competition is one of the most challenging international proving grounds for contemporary AI research.  Exactly because of the high level of complexity and a lack of reliable strategic guidelines, the pervasive attitude has been that the problem can most successfully be attacked by human expertise, possibly assisted by some level of machine learning.  This led, in RoboCup'97, to a field of simulator teams all of whose level and style of play were heavily influenced by the human designers of those teams.  It is the thesis of our work that machine learning, if given the opportunity to design (learn) "everything" about how the simulator team operates, can develop a competitive simulator team that solves the problem utilizing highly successful, if largely nonhuman, styles of play.  To this end, Darwin United is a team of eleven players that have been evolved as a team of coordinated agents in the RoboCup simulator.  Each agent is given a subset of the lowest level perceptual inputs and must learn to execute series of the most basic actions (turn, kick, dash) in order to participate as a member of the team.  This paper presents our motivation, our approach, and the specific construction of our team that created itself from scratch. 
Darwinian Programming and Engineering Design Using Genetic Programming| ABSTRACT One of the central challenges of computer science is to build a system that can automatically create computer programs that are competitive with those produced by humans.  This paper presents a candidate set of criteria that identify when a machine-created solution is competitive with a human-produced result.  We argue that the field of design is a useful testbed for determining whether an automated technique can produce results that are competitive with human-produced results.  We present several results that are competitive with the products of human creativity and inventiveness.  This claim is supported by the fact that each of the results infringe on previously issued patents. 
Automatic Discovery Using Genetic Programming of an Unknown-Sized Detector of Protein Motifs Containing Repeatedly-Used Subexpressions| Abstract Automated methods of machine learning may be useful in discovering biologically meaningful patterns that are hidden in the rapidly growing databases of genomic and protein sequences.  However, almost all existing methods of automated discovery require that the user specify, in advance, the size and shape of the pattern that is to be discovered.  Moreover, existing methods do not have a workable analog of the idea of a reusable subroutine to exploit the recurring subpatterns of a problem environment.  Genetic programming can evolve complicated problem-solving expressions of unspecified size and shape.  When automatically defined functions are added to genetic programming, genetic programming becomes capable of efficiently capturing and exploiting recurring sub-patterns.  This paper describes how genetic programming with automatically defined functions successfully evolved motifs for detecting the D-E-A-D box family of proteins and for detecting the manganese superoxide dismutase family.  Both motifs were evolved without prespecifying their length.  Both evolved motifs employed automatically defined functions to capture the repeated use of common subexpressions.  When tested against the SWISS-PROT database of proteins, the two genetically evolved consensus motifs detect the two families either as well, or slightly better than, the comparable humanwritten motifs found in the PROSITE database. 
Four Problems for which a Computer Program Evolved by Genetic Programming is Competitive with Human Performance| Abstract -- It would be desirable if computers could solve problems without the need for a human to write the detailed programmatic steps.  That is, it would be desirable to have a domain-independent automatic programming technique in which "What You Want Is What You Get" ("WYWIWYG" -- pronounced "woweee-wig").  Genetic programming is such a technique.  This paper surveys three recent examples of problems (from the fields of cellular automata and molecular biology) in which genetic programming evolved a computer program that produced results that were slightly better than human performance for the same problem.  This paper then discusses the problem of electronic circuit synthesis in greater detail.  It shows how genetic programming can evolve both the topology of a desired electrical circuit and the sizing (numerical values) for each component in a crossover (woofer and tweeter) filter.  Genetic programming has also evolved the design for a lowpass filter, the design of an amplifier, and the design for an asymmetric bandpass filter that was described as being difficult-to-design in an article in a leading electrical engineering journal. 
PARALLEL GENETIC PROGRAMMING ON A NETWORK OF TRANSPUTERS| ABSTRACT This report describes the parallel implementation of genetic programming in the C programming language using a PC 486 type computer (running Windows) acting as a host and a network of transputers acting as processing nodes.  Using this approach, researchers of genetic algorithms and genetic programming can acquire computing power that is intermediate between the power of currently available workstations and that of supercomputers at a cost that is intermediate between the two.  A comparison is made of the computational effort required to solve the problem of symbolic regression of the Boolean even-S-parity function with different migration rates.  Genetic programming required the least computational effort with an 8% migration rate.  Moreover, this computational effort was less than that required for solving the problem with a serial computer and a panmictic population of the same size.  That is, apart from the nearly linear speed-up in executing a fixed amount of code inherent in the parallel implementation of genetic programming, parallelization delivered more than linear speed-up in solving the problem using genetic programming. 
State Abstraction for Programmable Reinforcement Learning Agents| Abstract Safe state abstraction in reinforcement learning allows an agent to ignore aspects of its current state that are irrelevant to its current decision, and therefore speeds up dynamic programming and learning.  This paper explores safe state abstraction in hierarchical reinforcement learning, where learned behaviors must conform to a given partial, hierarchical program.  Unlike previous approaches to this problem, our methods yield significant state abstraction while maintaining hierarchical optimality, i. e. , optimality among all policies consistent with the partial program.  We show how to achieve this for a partial programming language that is essentially Lisp augmented with nondeterministic constructs.  We demonstrate our methods on two variants of Dietterich's taxi domain, showing how state abstraction and hierarchical optimality result in faster learning of better policies and enable the transfer of learned skills from one problem to another. 
Generalized Prioritized Sweeping| Abstract Prioritized sweeping is a model-based reinforcement learning method that attempt to focus the agent's limited computational resources to achieve a good estimate of the value of environment states.  The classic account of prioritized sweeping uses an explicit, state-based representation of the value, reward, and model parameters.  Such a representation is unwieldy for dealing with complex environments and there is growing interest in learning with more compact representations.  We claim that classic prioritized sweeping is ill-suited for learning with such representations.  To overcome this deficiency, we introduce generalized prioritized sweeping, a principled method for generating representation-specific algorithms for model-based reinforcement learning.  We then apply this method for several representations, including state-based models and generalized model approximators (such as Bayesian networks).  We describe preliminary experiments that compare our approach with classical prioritized sweeping. 
Rapidly Reconfigurable Field-Programmable Gate Arrays for Accelerating Fitness Evaluation in Genetic Programming| ABSTRACT The dominant component of the computational burden of solving nontrivial problems with evolutionary algorithms is the task of measuring the fitness of each individual in each generation of the evolving population.  The advent of rapidly reconfigurable field-programmable gate arrays (FPGAs) and the idea of evolvable hardware opens the possiblity of embodying each individual of the evolving population into hardware for the purpose of accelerating the timeconsuming fitness evaluation task This paper demonstrates how the massive parallelism of the rapidly reconfigurable Xilinx XC6216 FPGA can be exploited to accelerate the computationally burdensome fitness evaluation task of genetic programming.  The work was done on Virtual Computing Corporation's lowcost HOTS expansion board for PC type computers.  A 16-step 7-sorter was evolved that has two fewer steps than the sorting network described in the 1962 O'Connor and Nelson patent on sorting networks and that has the same number of steps as the minimal 7-sorter that was devised by Floyd and Knuth subsequent to the patent. 
Use of Architecture-Altering Operations to Dynamically Adapt a Three-Way Analog Source Identification Circuit to Accommodate a New Source| ABSTRACT The problem of source identification involves correctly classifying an incoming signal into a category that identifies the signal's source.  The problem is difficult because information is not provided concerning each source's distinguishing characteristics and because successive signals from the same source differ.  The source identification problem can be made more difficult by dynamically changing the repertoire of sources while the problem is being solved.  We used genetic programming to evolve both the topology and the sizing (numerical values) for each component of an analog electrical circuit that can correctly classify an incoming analog electrical signal into three categories.  Then, the repertoire of sources was dynamically changed by adding a new source during the run.  The paper describes how the architecture-altering operations enabled genetic programming to adapt, during the run, to the changed environment.  Specifically, a three-way source identification circuit was evolved and then adapted into a four-way classifier, during the run, thereby successfully handling the additional new source. 
The Evolution of Agents that Build Mental Models and Create Simple Plans Using Genetic Programming|
Parallel genetic programming: A scalable implementation using the transputer architecture|
University Computer Science Department technical report STAN-|
Programmable HAMs|
Automatically changing the number of fitness cases: The rational allocation of trials|
Automatic discovery of protein motifs using genetic programming|
Automated synthesis of analog electrical circuits by means of genetic programming|
Parallel Genetic Programming on a Network of Transputers| Stanford University Computer Science Department technical report. 
Toward evolution of electronic animals using genetic programming| Artificial Life V:. 
Automatically choosing the number of fitness cases: The rational allocation of trials|
Classifying protein segments as transmembrane domains using architecture-altering operations in genetic programming|
Available through the World-Wide Web at|
Programmatic reinforcement learning agents|
State abstraction in phams|
Sur les permutations alternees,|
Genetic Programming III|
Automatically defined features: The simultaneous evolution of 2-dimensional feature detectors and an algorithm for using them|
Evolution of intricate long-distance communication signals in cellular automata using genetic programming|
Learning hierarchical behaviors|
Mobile Robot Obstacle Avoidance via Depth from Focus,|
Developments de sec x et tan x,|
Soccer server manual, version 4|0. 
Four Problems for which a Computer Problem Evolved By Genetic Programming is Competitive with Human Performance",|
Automatic synthesis of the topology and sizing for analog electrical circuits using genetic programming|
Real-time reinforcement learning in continuous domains|
Evolution of mapmaking ability: Strategies for the evolution of learning, planning, and memory using genetic programming|
The Automatic Programming of Agents that Learn Mental Models and Create Simple Plans of Action|
a), "Towards Evolution of Electronic Animals Using Genetic Programming",|
b),|
Paging in Lisp programs|
Method and apparatus for automated design of complex structures using genetic programming,|
Why The Upper Arm? Factors Contributing to the Design of an Accurate and Comfortable, Wearable Body Monitor|
Developpements de sec x et de tang x,|
Genetic Programming III Videotape: Human-Competitive Machine Intelligence|
A parallel implementation of genetic programming using the transputer architecture that achieves super-linear performance|
