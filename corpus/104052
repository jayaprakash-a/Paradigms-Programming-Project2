Basic-block Instruction Scheduling Using Reinforcement Learning and Rollouts
 Abstract The execution order of a block of computer instructions on a pipelined machine can make a difference in its running time by a factor of two or more.  In order to achieve the best possible speed, compilers use heuristic schedulers appropriate to each specific architecture implementation.  However, these heuristic schedulers are time-consuming and expensive to build.  We present empirical results using both rollouts and reinforcement learning to construct heuristics for scheduling basic blocks.  In simulation, both the rollout scheduler and the reinforcement learning scheduler outperformed a commercial scheduler on several applications.  1 Motivation Although high-level code is generally written as if it were going to be executed sequentially, most modern computers exhibit parallelism in instruction execution using techniques such as the simultaneous issue of multiple instructions.  In order to take the best advantage of multiple pipelines, when a compiler turns the high-level code into machine instructions, it employs an instruction scheduler to reorder the machine code.  The scheduler needs to reorder the instructions in such a way as to preserve the original in-order semantics of the high level code while having the reordered code execute as quickly as possible.  An efficient schedule can produce a speedup in execution of a factor of two or more.  Building an instruction scheduler can be an arduous process.  Schedulers are specific to the architecture of each machine and the general problem of instruction scheduling is NP-hard (Proebsting).  Because of these characteristics, schedulers are currently built using handcrafted heuristic algorithms.  However, this method is both labor and time intensive.  Building algorithms to select and combine heuristics automatically using machine learning techniques can save time and money.  As computer architects develop new machine designs, new schedulers would be built automatically to test design changes rather than requiring hand-built heuristics for each change.  This would allow architects to explore the design space more thoroughly and to use more accurate metrics in evaluating designs.  A second possible use of machine learning techniques in instruction scheduling is by the end user.  Instead of scheduling code using a static scheduler trained on benchmarks when the compiler was written, a user would employ a learning scheduler to discover important characteristics of that user's code.  The learning scheduler would exploit the user's coding characteristics to build schedules better tuned for that user.  Instruction scheduling is a large-scale optimization problem in several ways.  First, there can be millions of instructions and tens of thousands of basic blocks within a given program.  Scheduling each block optimally using exhaustive search is much too difficult and timeconsuming to work in practice.  Second, the problem of generalizing the scheduler from the training programs to all possible user programs is also an optimization problem.  With these motivations in mind, we formulated and tested two autonomous methods of building an instruction scheduler.  The first method used rollouts (Bertsekas, 1997; Bertsekas et al. , 1997; Tesauro and Galperin, 1996) and the second focused on reinforcement learning (RL) (Sutton and Barto, 1998).  Both methods were implemented for the Digital Alpha 21064.  The next section gives a brief overview of the domain.  For a complete description, see McGovern et al.  (1999).
